## Java Memory Structure.

### <a name="start"></a> Вопросы раздела

- [x] [1. Stack Memory](#stack)

- [x] [2. Heap Memory](#heap)

- [x] [3. Other run-time data areas (pc register, method area, run-time constant pool)](#data-areas)

- [x] [4. Garbage Collector (classic algorithms & java-specific implementations)](#gc)

- [x] [5. Reference Types](#reference)

- [x] [6. Memory Errors](#errors)

[К оглавлению](https://gitlab.com/ITokarev/java-core/blob/master/README.md)

  
 ---
 
### <a name="stack"></a> 1. Stack Memory
 
 ---
 
 Стековая память в Java работает по схеме LIFO (Последний-вошел-Первый-вышел). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода.
 Размер стековой памяти намного меньше объема памяти в куче.
 
![alt text](http://javadevblog.com/wp-content/uploads/2015/12/Stack_Heap.png)

[К оглавлению](#start)

---

### <a name="heap"></a> 2. Heap Memory

---

Java Heap (куча) используется Java Runtime для выделения памяти под объекты и JRE классы. Создание нового объекта также происходит в куче. Здесь работает сборщик мусора.

[К оглавлению](#start)

---

### <a name="data-areas"></a> 3 Other run-time data areas (pc register, method area, run-time constant pool)

---

#### pc register

The Java Virtual Machine can support many threads of execution at once. Each Java Virtual Machine thread has its own pc (program counter) register. At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method for that thread. If that method is not native, the pc register contains the address of the Java Virtual Machine instruction currently being executed. If the method currently being executed by the thread is native, the value of the Java Virtual Machine's pc register is undefined. The Java Virtual Machine's pc register is wide enough to hold a returnAddress or a native pointer on the specific platform.

#### method area

The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the "text" segment in an operating system process. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods used in class and instance initialization and interface initialization.

The method area is created on virtual machine start-up. Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it. This specification does not mandate the location of the method area or the policies used to manage compiled code. The method area may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger method area becomes unnecessary. The memory for the method area does not need to be contiguous.

A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the method area, as well as, in the case of a varying-size method area, control over the maximum and minimum method area size.

The following exceptional condition is associated with the method area:

**If memory in the method area cannot be made available to satisfy an allocation request, the Java Virtual Machine throws an OutOfMemoryError.**

### run-time constant pool

A run-time constant pool is a per-class or per-interface run-time representation of the constant_pool table in a class file. It contains several kinds of constants, ranging from numeric literals known at compile-time to method and field references that must be resolved at run-time. The run-time constant pool serves a function similar to that of a symbol table for a conventional programming language, although it contains a wider range of data than a typical symbol table.

Each run-time constant pool is allocated from the Java Virtual Machine's method area. The run-time constant pool for a class or interface is constructed when the class or interface is created by the Java Virtual Machine.

The following exceptional condition is associated with the construction of the run-time constant pool for a class or interface:

When creating a class or interface, if the construction of the run-time constant pool requires more memory than can be made available in the method area of the Java Virtual Machine, the Java Virtual Machine throws an OutOfMemoryError.

[More information](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html)

[К оглавлению](#start)

---

### <a name="gc"></a> 4. Garbage Collector (classic algorithms & java-specific implementations)

---

Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:

Serial (последовательный) — самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.

Parallel (параллельный) — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности.

Concurrent Mark Sweep (CMS) — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти.

Garbage-First (G1) — создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных.

#### Serial GC

Использование Serial GC включается опцией -XX:+UseSerialGC

При использовании данного сборщика куча разбивается на четыре региона, три из которых относятся к младшему поколению (Eden, Survivor 0 и Survivor 1), а один (Tenured) — к старшему:

![alt text](https://habrastorage.org/files/6b0/3a9/e6d/6b03a9e6d8174da3a7b228eb9acbe001.png)

Среднестатистический объект начинает свою жизнь в регионе Eden. Именно сюда его помещает JVM в момент создания. Но со временем может оказаться так, что места для вновь создаваемого объекта в Eden нет, в таких случаях запускается малая сборка мусора.

Первым делом такая сборка находит и удаляет мертвые объекты из Eden. Оставшиеся живые объекты переносятся в пустой регион Survivor. Один из двух регионов Survivor всегда пустой, именно он выбирается для переноса объектов из Eden:

![alt text](https://habrastorage.org/files/245/fca/ecf/245fcaecfc9e484ebbdadcdbc5e05ffc.png)

Мы видим, что после малой сборки регион Eden полностью опорожнен и может быть использован для размещения новых объектов. Но рано или поздно наше приложение опять займет всю область Eden и JVM снова попытается провести малую сборку, на этот раз очищая Eden и частично занятый Survivor 0, после чего перенося все выжившие объекты в пустой регион Survivor 1:

![alt text](https://habrastorage.org/files/6cc/732/93d/6cc73293ddb04e6a9aa273cc6a81f2dd.png)

В следующий раз в качестве региона назначения опять будет выбран Survivor 0. Пока места в регионах Survivor достаточно, все идет хорошо:

![alt text](https://habrastorage.org/files/e70/ee9/041/e70ee904149845bf9fe70c8524ddf263.png)

JVM постоянно следит за тем, как долго объекты перемещаются между Survivor 0 и Survivor 1, и выбирает подходящий порог для количества таких перемещений, после которого объекты перемещаются в Tenured, то есть переходят в старшее поколение. Если регион Survivor оказывается заполненным, то объекты из него также отправляются в Tenured:

![alt text](https://habrastorage.org/files/20b/a5e/2fa/20ba5e2faa614c558593413268b729c2.png)

В случае, когда места для новых объектов не хватает уже в Tenured, в дело вступает полная сборка мусора, работающая с объектами из обоих поколений. При этом старшее поколение не делится на подрегионы по аналогии с младшим, а представляет собой один большой кусок памяти, поэтому после удаления мертвых объектов из Tenured производится не перенос данных (переносить уже некуда), а их уплотнение, то есть размещение последовательно, без фрагментации. Такой механизм очистки называется Mark-Sweep-Compact по названию его шагов (пометить выжившие объекты, очистить память от мертвых объектов, уплотнить выжившие объекты).

![alt text](https://habrastorage.org/files/05b/268/25d/05b26825d6d5484083f6354b1d114313.png)

#### Parallel GC

Параллельный сборщик включается опцией -XX:+UseParallelGC.

При подключении параллельного сборщика используются те же самые подходы к организации кучи, что и в случае с Serial GC — она делится на такие же регионы Eden, Survivor 0, Survivor 1 и Old Gen (знакомый нам под именем Tenured), функционирующие по тому же принципу. Но есть два принципиальных отличия в работе с этими регионами: во-первых, сборкой мусора занимаются несколько потоков параллельно; во-вторых, данный сборщик может самостоятельно подстраиваться под требуемые параметры производительности.

Для определения количества потоков, которые будут использоваться при сборке мусора, на компьютере с N ядрами процессора, JVM по умолчанию применяет следующую формулу: если N ≤ 8, то количество потоков равно N, иначе для получения количества потоков N домножается на коэффициент, зависящий от других параметров, обычно это 5/8, но на некоторых платформах коэффициент может быть меньше.

По умолчанию и малая и полная сборка задействуют многопоточность. Малая пользуется ею при переносе объектов в старшее поколение, а полная — при уплотнении данных в старшем поколении.

Каждый поток сборщика получает свой участок памяти в регионе Old Gen, так называемый буфер повышения (promotion buffer), куда только он может переносить данные, чтобы не мешать другим потокам. Такой подход ускоряет сборку мусора, но имеет и небольшое негативное последствие в виде возможной фрагментации памяти:

![alt text](https://habrastorage.org/files/bed/e1a/c4c/bede1ac4c5c84aa9a3363a446b1be0b6.png)

Интеллектуальная составляющая улучшений параллельного сборщика относительно последовательного заключается в том, что у него есть настройки, ориентированные на достижение необходимой вам эффективности сборки мусора. Вы можете указать устраивающие вас параметры производительности — максимальное время сборки и/или пропускную способность — и сборщик будет изо всех сил стараться не превышать заданные пороги. Для этого он будет использовать статистику уже прошедших сборок мусора и исходя из нее планировать параметры дальнейших сборок: варьировать размеры поколений, менять пропорции регионов.

Например, если при малой сборке JVM не удается укладываться в отведенное вами время, размер младшего поколения может быть уменьшен. Если не удается достигнуть заданной пропускной способности, а с задержкой проблем нет, то размер поколения будет увеличен. И так далее.

При этом следует иметь в виду, что в статистике игнорируются сборки мусора, запущенные вами вручную.

В случае, если вы задали слишком жесткие требования, которые сборщик не может выполнить, он будет ориентироваться на следующие приоритеты (в порядке убывания важности):

 * Снижение максимальной паузы.
 * Повышение пропускной способности.
 * Минимизация используемой памяти.

При этом Parallel GC оставляет нам возможность самостоятельно корректировать размеры регионов, как и в последовательном сборщике. Но не рекомендуется делать и то и другое одновременно, чтобы не дезориентировать алгоритмы автоматической подстройки. Либо мы выделяем приложению достаточно памяти, указываем желаемые параметры производительности и наблюдаем со стороны, либо сами залезаем в настройки регионов, но тогда лишаемся права требовать от сборщика автоматической подстройки под нужные нам критерии производительности. Ругаться он на нас в случае нарушения данного правила не будет, но и эффективно выполнять свою работу тоже не сможет.

#### CMS (Concurrent Mark Sweep) GC 

Использование CMS GC включается опцией -XX:+UseConcMarkSweepGC.

CMS GC использует ту же самую организацию памяти, что и уже рассмотренные Serial / Parallel GC: регионы Eden + Survivor 0 + Survivor 1 + Tenured и такие же принципы малой сборки мусора. Отличия начинаются только тогда, когда дело доходит до полной сборки. В случае CMS ее называют старшей (major) сборкой, а не полной, так как она не затрагивает объекты младшего поколения. В результате, малая и старшая сборки здесь всегда разделены. Одним из побочных эффектов такого разделения является то, что все объекты младшего поколения (даже потенциально мертвые) могут играть роль корней при определении статуса объектов в старшем поколении.

Важным отличием сборщика CMS от рассмотренных ранее является также то, что он не дожидается заполнения Tenured для того, чтобы начать старшую сборку. Вместо этого он трудится в фоновом режиме постоянно, пытаясь поддерживать Tenured в компактном состоянии.

Давайте рассмотрим, что из себя представляет старшая сборка мусора при использовании CMS GC.

Начинается она с остановки основных потоков приложения и пометки всех объектов, напрямую доступных из корней. После этого приложение возобновляет свою работу, а сборщик параллельно с ним производит поиск всех живых объектов, доступных по ссылкам из тех самых помеченных корневых объектов (эту часть он делает в одном или в нескольких потоках).

Естественно, за время такого поиска ситуация в куче может поменяться, и не вся информация, собранная во время поиска живых объектов, оказывается актуальной. Поэтому сборщик еще раз приостанавливает работу приложения и просматривает кучу для поиска живых объектов, ускользнувших от него за время первого прохода. При этом допускается, что в живые будут записаны объекты, которые на время окончания составления списка таковыми уже не являются. Эти объекты называются плавающим мусором (floating garbage), они будут удалены в процессе следующей сборки.

После того, как живые объекты помечены, работа основных потоков приложения возобновляется, а сборщик производит очистку памяти от мертвых объектов в нескольких параллельных потоках. При этом следует иметь в виду, что после очистки не производится упаковка объектов в старшем поколении, так как делать это при работающем приложении весьма затруднительно.

![alt text](https://habrastorage.org/files/f9f/d54/9a2/f9fd549a2a104f1eb7acf5098dd0afe8.png)

Отдельно следует рассмотреть ситуацию, когда сборщик не успевает очистить Tenured до того момента, как память полностью заканчивается. В этом случае работа приложения останавливается, и вся сборка производится в последовательном режиме. Такая ситуация называется сбоем конкурентного режима (concurrent mode failure). Сборщик сообщает нам об этих сбоях при включенных опциях -verbose:gc или -Xloggc:filename.

#### G1 (Garbage First) GC

G1 включается опцией Java -XX:+UseG1GC.

Первое, что бросается в глаза при рассмотрении G1 — это изменение подхода к организации кучи. Здесь память разбивается на множество регионов одинакового размера. Размер этих регионов зависит от общего размера кучи и по умолчанию выбирается так, чтобы их было не больше 2048, обычно получается от 1 до 32 МБ. Исключение составляют только так называемые громадные (humongous) регионы, которые создаются объединением обычных регионов для размещения очень больших объектов.

Разделение регионов на Eden, Survivor и Tenured в данном случае логическое, регионы одного поколения не обязаны идти подряд и даже могут менять свою принадлежность к тому или иному поколению. Пример разделения кучи на регионы может выглядеть следующим образом (количество регионов сильно приуменьшено):

![alt text](https://habrastorage.org/files/34d/781/181/34d781181f5e4481be98557899ae0cf2.png)

Малые сборки выполняются периодически для очистки младшего поколения и переноса объектов в регионы Survivor, либо их повышения до старшего поколения с переносом в Tenured. Над переносом объектов трудятся несколько потоков, и на время этого процесса работа основного приложения останавливается. Это уже знакомый нам подход из рассмотренных ранее сборщиков, но отличие состоит в том, что очистка выполняется не на всем поколении, а только на части регионов, которые сборщик сможет очистить не превышая желаемого времени. При этом он выбирает для очистки те регионы, в которых, по его мнению, скопилось наибольшее количество мусора и очистка которых принесет наибольший результат. Отсюда как раз название Garbage First — мусор в первую очередь.

А с полной сборкой (точнее, здесь она называется смешанной (mixed)) все немного хитроумнее, чем в рассмотренных ранее сборщиках. В G1 существует процесс, называемый циклом пометки (marking cycle), который работает параллельно с основным приложением и составляет список живых объектов.
 * Initial mark. Пометка корней (с остановкой основного приложения) с использованием информации, полученной из малых сборок.
 * Concurrent marking. Пометка всех живых объектов в куче в нескольких потоках, параллельно с работой основного приложения.
 * Remark. Дополнительный поиск не учтенных ранее живых объектов (с остановкой основного приложения).
 * Cleanup. Очистка вспомогательных структур учета ссылок на объекты и поиск пустых регионов, которые уже можно использовать для размещения новых объектов. Первая часть этого шага выполняется при остановленном основном приложении.

Следует иметь в виду, что для получения списка живых объектов G1 использует алгоритм Snapshot-At-The-Beginning (SATB), то есть в список живых попадают все объекты, которые были таковыми на момент начала работы алгоритма, плюс все объекты, созданные за время его выполнения. Это, в частности, означает, что G1 допускает наличие плавающего мусора, с которым мы познакомились при рассмотрении сборщика CMS.

После окончания цикла пометки G1 переключается на выполнение смешанных сборок. Это значит, что при каждой сборке к набору регионов младшего поколения, подлежащих очистке, добавляется некоторое количество регионов старшего поколения. Количество таких сборок и количество очищаемых регионов старшего поколения выбирается исходя из имеющейся у сборщика статистики о предыдущих сборках таким образом, чтобы не выходить за требуемое время сборки. Как только сборщик очистил достаточно памяти, он переключается обратно в режим малых сборок.

Очередной цикл пометки и, как следствие, очередные смешанные сборки будут запущены тогда, когда заполненность кучи превысит определенный порог.

Смешанная сборка мусора в приведенном выше примере кучи может пройти вот так:

![alt text](https://habrastorage.org/files/8ee/d12/62d/8eed1262d47a407a9f64f2df8635bdb6.png)

Может оказаться так, что в процессе очистки памяти в куче не остается свободных регионов, в которые можно было бы копировать выжившие объекты. Это приводит к возникновению ситуации allocation (evacuation) failure, подобие которой мы видели в CMS. В таком случае сборщик выполняет полную сборку мусора по всей куче при остановленных основных потоках приложения.

Опираясь на уже упомянутую статистику о предыдущих сборках, G1 может менять количество регионов, закрепленных за определенным поколением, для оптимизации будущих сборок.

С точки зрения JVM любой объект размером больше половины региона считается громадным и обрабатывается специальным образом:
 * Он никогда не перемещается между регионами.
 * Он может удаляться в рамках цикла пометки или полной сборки мусора.
 * В регион, занятый громадным объектом, больше никого не подселяют, даже если в нем остается свободное место.
 
 [К оглавлению](#start)

---

### <a name="reference"></a> 5. Reference Types

---
	
В Java существует 4 типа ссылок на объекты:

 * strong reference
 * soft reference
 * weak reference
 * phantom reference

В Java объекты, создаваемые через оператор new создаются по strong ссылке. Сборщик мусора (garbage collector) уничтожает такие объекты только тогда, когда на них больше не остается сильных (strong) ссылок.
В пакете java.lang.ref есть 3 класса, которые описывают оставшиеся 3 типа ссылок, соответственно SoftReference, WeakReference, PhantomReference.
Объекты, созданные через SoftReference, будут собраны в случае, если JVM требует память. То есть имеется гарантия, что все soft reference объекты будут собраны перед тем, как JVM выбросит OutOfMemoryError. SoftReference часто используется для кешей, потребляющих большое количество памяти.
WeakReference не спасает объект от финализации, даже если имеется достаточное количество свободной памяти. Как только на объект не останется strong и soft ссылок, он может быть финализирован. Используется для кешей и для создания цепей связанных между собой объектов.
Объекты, созданные через PhantomReference, уничтожаются тогда, когда GC определяют, что ссылаемые объекты могут быть освобождены. Этот тип ссылок используется как альтернатива финализации (для более гибкого освобождения ресурсов).

[К оглавлению](#start)
	
---	

### <a name="errors"></a> 6. Memory Errors
	
---

 1. java.lang.OutOfMemoryError: Java heap space
Возникает при переполнении памяти в Heap.

 2. java.lang.OutOfMemoryError: GC Overhead limit exceeded
	Редкая ошибка которая возникает при постоянной работе GC в течении длительного времени, когда очистка мусора происходит очень медленно.

 3. java.lang.OutOfMemoryError: Permgen space
Ошибка возникает в результате переполнения PermGen области памяти, что может произойти в результате подгрузки огромных классов или большого количества этих классов.

 4. java.lang.OutOfMemoryError: Metaspace
	Аналогично java.lang.OutOfMemoryError: Permgen space, только в java 8, где статичный Permgen заменили на динамически расширяющийся  Metaspace.

 5. java.lang.OutOfMemoryError: Unable to create new native thread
Выбрасывается когда не хватает места в памяти для создания нового потока.

 6. java.lang.OutOfMemoryError: request size bytes for reason
	Выбрасывается когда заканчивается место в файле подкачки.

 7. java.lang.OutOfMemoryError: Requested array size exceeds VM limit
	Выбрасывается при попытке создать массив (или коллекцию) длина которого превышает величину разрешенную платформой.
	
[К оглавлению](#start)
	