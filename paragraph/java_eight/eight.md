## Java 8

### <a name="start"></a> Вопросы раздела

- [x] [1. New Date/Time API](#date)

- [x] [2. Additions to interfaces (static methods, final methods). Method references](#interface)

- [x] [3. Lambdas](#lambda)

- [x] [4. Build-In Functional Interfaces](#functional)

- [x] [5. Optional](#optional)

- [x] [6. Streams](#stream)
 
[К оглавлению](https://gitlab.com/ITokarev/java-core/blob/master/README.md)
 
---

#### <a name="date"></a> 1. New Date/Time API

---

*	LocalDate –  дата без времени и временных зон;
*	LocalTime – время без даты и временных зон;
*	LocalDateTime – дата и время без временных зон;
*	ZonedDateTime – дата и время с временной зоной;
*	DateTimeFormatter – форматирует даты в строки и наоборот, только для классов java.time;
*	Instant – количество секунд с Unix epoch time (полночь 1 января 1970 UTC);
*	Duration – продолжительность в секундах и наносекундах;
*	Period – период времени в годах, месяцах и днях;
*	TemporalAdjuster – корректировщик дат (к примеру, может получить дату следующего понедельника);


Данные классы являются immutable. Основные методы которые могут понадобиться для получение объектов типа даты это of(..), parse(“”), now()  Примеры создания объектов дат: 

```
LocalTime localTime = LocalTime.now(); 
LocalDate localDate = LocalDate.now(); 
LocalDateTime fromLocalTime = localTime.atDate(localDate); 
LocalDateTime fromDateTime = localDate.atTime(localTime); 
fromDateTime = localDate.atTime(23,59,57,01); 
```

Изменение значений дат:

```
        LocalTime localTime = LocalTime.now();
        LocalDate localDate = LocalDate.now();
        LocalDateTime localDateTime = LocalDateTime.now();
        localTime = localTime.minusMinutes(60)
                .plusHours(1)
                .plusSeconds(60)
                .minusMinutes(1);

        localDate = localDate.minusYears(1)
                .plusMonths(12)
                .minusDays(365)
                .plusYears(1);

        localDateTime = localDateTime.minusMinutes(60)
                .plusHours(1)
                .minusMinutes(1)
                .plusSeconds(60)
                .plusMonths(12)
                .minusYears(1)
                .minusDays(365)
                .plusYears(1);

        System.out.println(localTime); // 18:58:07.524
        System.out.println(localDate); // 2018-09-06
        System.out.println(localDateTime); // 2018-09-06T18:58:07.585
```

Вычислим дату следующего понедельника:
```
 localDate = localDate.with(TemporalAdjusters.next(DayOfWeek.MONDAY)); 
 System.out.println(localDate); // 2018-09-10
```

Instant
Объекты этого класса хранят миллисекунды с 01.01.1970 и являются местным эквивалентом старого доброго java.util.Date. Вот пару аналогий на тему, что с ним можно делать:
```
        Instant instant = Instant.now();
        System.out.println(instant); // 2018-09-06T16:02:55.850Z
        System.out.println(instant.toEpochMilli()); // 1536249775850

        instant = instant.plusSeconds(1).minusMillis(1000);
        System.out.println(instant); // 2018-09-06T16:02:55.850Z
```

ZonedDateTime
Класс аналог GregorianCalendar необходим для работы с часовыми поясами. Давайте посчитаем время в Минске с учетом временной зоны, а затем рассчитаем, какое сейчас время в Москве, после чего преобразуем его в LocalDateTime:

```
        ZoneId minskZone = ZoneId.of("Europe/Minsk");
        ZoneId moscowZone = ZoneId.of("Europe/Moscow");

        ZonedDateTime minskTime = ZonedDateTime.of(LocalDateTime.now(), minskZone);
        System.out.println(minskTime);  // 2018-09-06T19:04:07.265+03:00[Europe/Minsk]

        ZonedDateTime moscowTime = minskTime.withZoneSameInstant(moscowZone);
        System.out.println(moscowTime);  // 2018-09-06T19:04:07.265+03:00[Europe/Moscow]
        System.out.println(moscowTime.toLocalDateTime());  // 2018-09-06T19:04:07.265
```

Period.
Вот ещё одна очень модная и клевая фишка нового API. Позволяет прозрачно и удобно отсчитывать время от какой-то точки. Например, рассчитаем возраст:
```
        LocalDate today = LocalDate.now();
        LocalDate MyBirthday = LocalDate.of(1988, Month.APRIL, 20);

        Period period = Period.between(MyBirthday, today);
        long myDays = ChronoUnit.DAYS.between(MyBirthday, today);
        String result = String.format("You are %s years, %s months, and %s days old. (%s days total)",    period.getYears(),
                period.getMonths(),
                period.getDays(),
                myDays);
        System.out.println(result); // You are 30 years, 4 months, and 17 days old. (11096 days total)

```


Duration. 
Класс Duration служит для хранения продолжительности времени на основе секунд и наносекунд. Также для отображения длительности можно использовать и другие величины, вроде минут, часов, дней. Однако, основное предназначение этого класса - представление небольших промежутков времени. Для работы с длительными промежутками времени предназначен другой класс - Period.
Основные методы:

between(Temporal startInclusive, Temporal endExclusive)	
from(TemporalAmount amount)	
of(long amount, TemporalUnit unit)	
ofDays(long days)	
ofHours(long hours)	
ofMillis(long millis)	
ofMinutes(long minutes)	
ofNanos(long nanos)	
ofSeconds(long seconds)	
ofSeconds(long seconds, long nanoAdjustment)	
parse(CharSequence text)	

[К оглавлению](#start)

---

#### <a name="interface"></a> 2. Additions to interfaces (static methods, final methods). Method references

---

##### Default методы

Объявляются такие методы следующим образом

```java
interface Human {
    default void walk() {
        System.out.println("Ну, я пошел...");
    }
}
```

Использовать их можно только после получения экземпляра

```java
Human.walk(); //ошибка, так делать нельзя
Human human = new Human() {};
human.walk(); //а вот так можно
```

Default методы так же можно переопределять как и обычные методы

```java
class Runner implements Human{
    @Override
    public void walk() {
        System.out.println("Я бегу");
    }
}
```

Но есть один нюанс, рассмотрим следующий случай
```java
interface Human {
    default void walk() {
        System.out.println("Ну, я пошел...");
    }
}
interface Walkable {
    default void walk() {
        System.out.println("Ходьба");
    }
class Runner implements Human, Walkable {
}
```

В данном случае мы получим ошибку компиляции, ибо нельзя наследовать одновременно несколько default методов, не понятно какой из методов вызывать, если мы напишем следующий код

```java
Runner runner = new Runner();
runner.walk();
```
 
##### Static методы

C ними все проще, чем с default методами. Static методы в интерфейсе работают точно так же как и static методы в классе.

Объявление

```java
static void walk() {
    System.out.println("Ну, я пошел...");
}
```

и вызов

```java
Human.walk();
```

Наследовать static методы в интерфейсе нельзя, как и static методы в классах.

Так же нельзя вызывать static метод интерфейса из класса наследника

```java
public static void main(String[] args) {
    HomoSapiens.walk(); //ошибка компиляции
}

interface Human {
    static void walk() {
        System.out.println("Ну, я пошел...");
    }
}

class HomoSapiens implements Human{
}
```

##### Method references

Ссылочные методы внедряют полезный синтаксис, чтобы ссылаться на существующие методы или конструкторы Java-классов или объектов (экземпляров). Совместно с лямбда-выражениями, ссылочные методы делают языковые конструкции компактными и лаконичными, делая его шаблонным.

Ниже представлен класс Car как пример различных определений методов, давайте выделим четыре поддерживаемых типа ссылочных методов:
```java
public static class Car {
    public static Car create( final Supplier< Car > supplier ) {
        return supplier.get();
    }             
	         
    public static void collide( final Car car ) {
        System.out.println( "Collided " + car.toString() );
    }
	         
    public void follow( final Car another ) {
        System.out.println( "Following the " + another.toString() );
    }
	         
    public void repair() {  
        System.out.println( "Repaired " + this.toString() );
    }
}
```

Первый ссылочный метод – ссылка на конструктор с синтаксисом Class::new или альтернативный для дженериков (generics) Class< T >::new. Обратите внимание, что конструктор не имеет аргументов.

```java
final Car car = Car.create( Car::new );
final List< Car > cars = Arrays.asList( car );
```

Второй вариант это ссылка на статический метод с синтаксисом Class::static_method. Обратите внимание, что метод принимает ровно один параметр типа Car.
```java
cars.forEach( Car::collide );
```

Третий тип – ссылка на метод экземпляра произвольного объекта определенного типа с синтаксисом Class::method. Обратите внимание, что никакие аргументы не принимаются методом.

```java
cars.forEach( Car::repair );
```

И последний, четвертый тип – ссылка на метод экземпляра определенного класса с синтаксисом instance::method. Обратите внимание, что метод принимает только один параметр типа Car.

```java
final Car police = Car.create( Car::new );
cars.forEach( police::follow );
```

Запуск всех этих примеров как Java-программы производит следующий вывод на консоль (ссылка на класс Car может отличаться):

Collided com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d
Repaired com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d
Following the com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d

[Документация](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html)

[К оглавлению](#start)

---

#### <a name="lambda"></a> 3. Lambdas

---

Лямбда-выражение представляет собой блок кода, который можно передать в другое место, поэтому он может быть выполнен позже, один или несколько раз. Прежде чем углубляться в синтаксис (и любопытное название), давайте сделаем шаг назад и увидим, где вы использовали аналогичные блоки кода в Java до этого. 

Если вы хотите выполнить действия в отдельном потоке, вы помещаете их в метод run из Runnable, вот так:

```java
class MyRunner implements Runnable {
    public void run() {
        for (int i = 0; i < 1000; i++)
           doWork();
        }
        ...
}
```

Затем, когда вы хотите выполнить этот код, вы создаете экземпляр класса MyRunner. Вы можете поместить экземпляр в пул потоков, или поступить проще и запустить новый поток:
MyRunner r = new MyRunner();
new Thread(r).start();

Ключевым моментом является то, что метод run содержит код, который нужно выполнить в отдельном потоке.

Рассмотрим сортировку с использованием пользовательского компаратора. Если вы хотите отсортировать строки по длине, а не по умолчанию, вы можете передать объект Comparator в метод sort:
```java
class LengthStringComparator implements Comparator<String> {
    public int compare(String firstStr, String secondStr) {
        return Integer.compare(firstStr.length(),secondStr.length());
    }
}
   
Arrays.sort(strings, new LengthStringComparator ());
```

Метод sort все так же вызывает метод compare, переставляя элементы, если они стоят не по порядку, пока массив не будет отсортирован. Вы предоставляете методу sort фрагмент кода, необходимый для сравнения элементов, и этот код встраивается в остальную часть логики сортировки, которую вам, вероятно, не нужно переопределять. Обратите внимание, что вызов Integer.compare (х, у) возвращает ноль, если х и у равны, отрицательное число, если х < у, и положительное число, если х > у. Этот статический метод был добавлен в Java 7. Вы не должны вычислять х – y, чтобы сравнивать х и у, потому что расчет может вызвать переполнение для больших операндов противоположного знака.

В качестве другого примера отложенного выполнения рассмотрим коллбэк для кнопки. Вы помещаете действие обратного вызова в метод класса, реализующего интерфейс слушателя, создаете экземпляр, и регистрируете экземпляр. Это настолько распространенный сценарий, что многие программисты используют синтаксис «анонимный экземпляр анонимного класса»:
button.setOnAction(new EventHandler<ActionEvent>() {
    public void handle(ActionEvent event) {
        System.out.println("The button has been clicked!");
    }
});

Здесь важен код внутри метода handle. Этот код выполняется всякий раз, когда нажимается кнопка.

Поскольку Java 8 позиционирует JavaFX в качестве преемника инструментария Swing GUI, я использую JavaFX в этих примерах. Детали не имеют значения. В каждой библиотеке пользовательского интерфейса, будь то Swing, JavaFX или Android, вы передаете кнопке некоторый код, который вы хотите запустить, когда кнопка нажата.

Во всех трех примерах вы видели один и тот же подход. Блок кода кому-то передавался — пулу потоков, методу сортировки или кнопке. Этот код вызывался некоторое время спустя.

До сих пор передача кода не была простой в Java. Вы не могли просто передать блоки кода куда угодно. Java является объектно-ориентированным языком, так что вы должны были создать объект, принадлежащий к классу, у которого есть метод с нужным кодом.
В других языках можно работать с блоками кода непосредственно. Проектировщики Java сопротивлялись добавлению этой функции в течение длительного времени. В конце концов, большая сила Java в ее простоте и последовательности. Язык может стать крайне беспорядочным, если будет включать в себя все функции, которые дают чуть более краткий код. Тем не менее, в тех других языках, это не просто легче порождать поток или зарегистрировать обработчик кнопки щелчка; многие их API проще, более последовательны и мощные. В Java, можно было бы написать подобные интерфейсы, которые принимают объекты классов, реализующих определенную функцию, но такие API было бы неудобно использовать.

В последнее время вопрос был не в том, расширять Java для функционального программирования или нет, а как это сделать. Потребовалось несколько лет экспериментов, прежде чем выяснилось, что это хорошо подходит для Java. В следующем разделе вы увидите, как можно работать с блоками кода в Java 8.

Синтаксис лямбда-выражений

Рассмотрим предыдущий пример сортировки еще раз. Мы передаем код, который проверяет, какая строка короче. Мы вычисляем
Integer.compare(firstStr.length(), secondStr.length())

Что такое firstStr и secondStr? Они оба строки! Java является строго типизированным языком, и мы должны указать типы:
(String firstStr, String secondStr)
     -> Integer.compare(firstStr.length(),secondStr.length())


Вы только что видели ваше первое лямбда-выражение! Такое выражение является просто блоком кода вместе со спецификацией любых переменных, которые должны быть переданы в код.

Почему такое название? Много лет назад, когда еще не было никаких компьютеров, логик Алонзо Чёрч хотел формализовать, что значит для математической функции быть эффективно вычисляемой. (Любопытно, что есть функции, которые, как известно, существуют, но никто не знает, как вычислить их значения.) Он использовал греческую букву лямбда (λ), чтобы отметить параметры. Если бы он знал о Java API, он написал бы что-то не сильно похожее на то, что вы видели, скорее всего.

Почему буква λ? Разве Чёрч использовал все буквы алфавита? На самом деле, почтенный труд Principia Mathematica использует символ ˆ для обозначения свободных переменных, которые вдохновили Чёрча использовать заглавную лямбда (Λ) для параметров. Но, в конце концов, он переключился на строчной вариант буквы. С тех пор, выражение с переменными параметрами было названо «лямбда-выражение».

Вы только что видели одну форму лямбда-выражений в Java: параметры, стрелку -> и выражение. Если код выполняет вычисление, которое не вписывается в одно выражение, запишите его так же, как вы бы написали метод: заключенный в {} и с явными выражениями return. Например,
(String firstStr, String secondStr) -> {
    if (firstStr.length() < secondStr.length()) return -1;
    else if (firstStr.length() > secondStr.length()) return 1;
    else return 0;
}

Если лямбда-выражение не имеет параметров, вы все равно ставите пустые скобки, так же, как с методом без параметров:
() -> { for (int i = 0; i < 1000; i++) doWork(); }

Если типы параметров лямбда-выражения можно вывести, можно опустить их. Например,
Comparator<String> comp
    = (firstStr, secondStr) // Same as (String firstStr, String secondStr)
        -> Integer.compare(firstStr.length(),secondStr.length());

Здесь компилятор может сделать вывод, что firstStr и secondStr должны быть строками, потому что лямбда-выражение присваивается компаратору строк. (Мы посмотрим на это присваивание повнимательнее позже.) 

Если метод имеет один параметр выводимого типа, вы можете даже опустить скобки:
EventHandler<ActionEvent> listener = event ->
    System.out.println("The button has been clicked!");
        // Instead of (event) -> or (ActionEvent event) ->


Вы можете добавить аннотации или модификатор final к параметрам лямбды таким же образом, как и для параметров метода:
(final String var) -> ...
(@NonNull String var) -> ...

Вы никогда не указываете тип результата лямбда-выражения. Это всегда выясняется из контекста. Например, выражение
(String firstStr, String secondStr) -> Integer.compare(firstStr.length(), secondStr.length())

может быть использовано в контексте, где ожидается результат типа int. 

Обратите внимание, что лямбда-выражение не может возвращать значение в каких-то ветках, а в других не возвращать. Например, (int x) -> { if (x <= 1) return -1; } является недопустимым.

[К оглавлению](#start)

---

#### <a name="functional"></a> 4. Build-In Functional Interfaces

---

Как мы уже обсуждали, в Java есть много существующих интерфейсов, которые инкапсулируют блоки кода, такие, как Runnable или Comparator. Лямбда-выражения имеют обратную совместимость с этими интерфейсами.

Вы можете поставить лямбда-выражение всякий раз, когда ожидается объект интерфейса с одним абстрактным методом. Такой интерфейс называется функциональным интерфейсом.

Вы можете удивиться, почему функциональный интерфейс должен иметь единственный абстрактный метод. Разве не все методы в интерфейсе абстрактные? На самом деле, всегда было возможно для интерфейса переопределить методы класса Object, например, toString или clone, и эти объявления не делают методы абстрактными. (Некоторые интерфейсы в Java API переопределяют методы Object, чтобы присоединить javadoc-комментарии. Посмотрите Comparator API для примера.) Что еще более важно, как вы вскоре увидите, в Java 8 интерфейсы могут объявлять неабстрактные методы.

Чтобы продемонстрировать преобразование в функциональный интерфейс, рассмотрим метод Arrays.sort. Его второй параметр требуется экземпляр Comparator, интерфейса с единственным методом. Просто предоставьте лямбду:
Arrays.sort(strs,
    (firstStr, secondStr) -> Integer.compare(firstStr.length(), secondStr.length()));

За кулисами, метод Arrays.sort получает объект некоторого класса, реализующего Comparator . Вызов метода compare на этом объекте выполняет тело лямбда-выражения. Управление этими объектами и классами полностью зависит от реализации, и это может быть что-то гораздо более эффективное, чем использование традиционных внутренних классов. Лучше всего думать о лямбда-выражении как о функции, а не об объекте, и признать, что он может быть передан функциональному интерфейсу. 

Это преобразование в интерфейсы – это то, что делает лямбда-выражения настолько мощными. Синтаксис короткий и простой. Вот еще один пример:
button.setOnAction(event ->
    System.out.println("The button has been clicked!"));

Этот код очень легко читать. 

В самом деле, преобразование в функциональный интерфейс - это единственное, что вы можете сделать с лямбда-выражением в Java. В других языках программирования, которые поддерживают функциональные литералы, можно объявить типы функций, таких как (String, String) -> int, объявлять переменные этих типов, и использовать переменные для сохранения функциональных выражений. В Java вы не можете даже присвоить лямбда-выражение переменной типа Object, потому Object не является функциональным интерфейсом. Проектировщики Java решили строго придерживаться знакомой концепции интерфейсов, а не добавлять типы функций в язык.

Java API определяет несколько универсальных функциональных интерфейсов в пакете java.util.function. Один из интерфейсов, BiFunction <T, U, R>, описывает функции с типами Т и U и типом возвращаемого значения R. Вы можете сохранить вашу лямбду сравнения строк в переменной этого типа:
BiFunction<String, String, Integer> compareFunc
    = (firstStr, secondStr) -> Integer.compare(firstStr.length(), secondStr.length());

Тем не менее, это не поможет вам с сортировкой. Не существует метода Arrays.sort, который принимает BiFunction. Если вы использовали функциональный язык программирования и прежде, вы можете найти это любопытным. Но для Java программистов это довольно естественно. Такой интерфейс, как Comparator, имеет конкретную цель, а не просто метод с заданным параметром и возвращаемым типом. Java 8 сохраняет этот стиль. Если вы хотите сделать что-то с лямбда-выражениями , вы все еще должны понимать назначение этого выражения, и иметь конкретный функциональный интерфейс для этого.

Интерфейсы из java.util.function используются в нескольких Java 8 интерфейсах API , и вы, вероятно, увидите их в других местах в будущем. Но имейте в виду, что вы можете одинаково хорошо преобразовать лямбда-выражение в функциональный интерфейс, который является частью любого API, который вы используете сегодня. Кроме того, вы можете пометить любой функциональный интерфейс с помощью аннотации @FunctionalInterface. Это имеет два преимущества. Компилятор проверяет, что аннотированная сущность представляет собой интерфейс с одним абстрактным методом. И страница Javadoc включает в себя утверждение, что ваш интерфейс является функциональным интерфейсом. Вы не обязаны использовать аннотацию. Любой интерфейс с одним абстрактным методом является, по определению, функциональным интерфейсом. Но использование аннотации @FunctionalInterface - это хорошая идея.

Наконец, заметим, что checked исключения могут возникнуть при преобразовании лямбды в экземпляр функционального интерфейса. Если тело лямбда-выражения может бросить checked исключение, это исключение должно быть объявлено в абстрактном методе целевого интерфейса. Например, следующее было бы ошибкой:
Runnable sleepingRunner = () -> { System.out.println("…"); Thread.sleep(1000); };
    // Error: Thread.sleep can throw a checkedInterruptedException

Поскольку Runnable.run не может бросить исключение, это присваивание является некорректным. Чтобы исправить ошибку, у вас есть два варианта. Вы можете поймать исключение в теле лямбда-выражения. Или вы можете присвоить лямбду интерфейсу, один абстрактный метод которого может бросить исключение. Например, метод call из интерфейса Callable может бросить любое исключение. Таким образом, вы можете присвоить лямбду Callable (если добавить return null).

[К оглавлению](#start)

---

#### <a name="optional"></a> 5. Optional

----

Как получить объект через Optional?

Как уже было сказано, класс Optional может содержать объект, а может содержать null. К примеру, попытаемся извлечь из репозитория юзера с заданным ID:

User = repository.findById(userId);

Возможно, юзер по такому ID есть в репозитории, а возможно, нет. Если такого юзера нет, к нам в стектрейс прилетает NullPointerException. Не имей мы в запасе класса Optional, нам пришлось бы изобретать какую-нибудь такую конструкцию:

User user;
if (Objects.nonNull(user =  repository.findById(userId))) {
(остальная борода пишется тут)
}

Согласитесь, не очень. Намного приятнее иметь дело с такой строчкой:

Optional<User> user = Optional.of(repository.findById(userId));

Мы получаем объект, в котором может быть запрашиваемый объект — а может быть null. Но с Optional надо как-то работать дальше, нам нужна сущность, которую он содержит (или не содержит).

Cуществует всего три категории Optional:

Optional.of — возвращает Optional-объект.

Optional.ofNullable -возвращает Optional-объект, а если нет дженерик-объекта, возвращает пустой Optional-объект.

Optional.empty — возвращает пустой Optional-объект.

Существует так же два метода, вытекающие из познания, существует обёрнутый объект или нет — isPresent() и ifPresent();

.ifPresent()

Метод позволяет выполнить какое-то действие, если объект не пустой.

Optional.of(repository.findById(userId)).ifPresent(createLog());

Если обычно мы выполняем какое-то действие в том случае, когда объект отсутствует (об этом ниже), то здесь как раз наоборот.

.isPresent()

Этот метод возвращает ответ, существует ли искомый объект или нет, в виде Boolean:

Boolean present = repository.findById(userId).isPresent();

Если Вы решили использовать нижеописанный метод get(), то не будет лишним проверить, существует ли данный объект, при помощи этого метода, например:

Optional<User> optionalUser = repository.findById(userId);
User user = optionalUser.isPresent() ? optionalUser.get() : new User();

Но такая конструкция лично мне кажется громоздкой, и о более удобных методах получения объекта мы поговорим ниже.

Как получить объект, содержащийся в Optional?

Существует три прямых метода дальнейшего получения объекта семейства orElse(); Как следует из перевода, эти методы срабатывают в том случае, если объекта в полученном Optional не нашлось.

orElse() — возвращает объект по дефолту.

orElseGet() — вызывает указанный метод.

orElseThrow() — выбрасывает исключение.

.orElse()

Подходит для случаев, когда нам обязательно нужно получить объект, пусть даже и пустой. Код, в таком случае, может выглядеть так:

User user = repository.findById(userId).orElse(new User());

Эта конструкция гарантированно вернёт нам объект класса User. Она очень выручает на начальных этапах познания Optional, а также, во многих случаях, связанных с использованием Spring Data JPA (там большинство классов семейства find возвращает именно Optional).

.orElseThrow()

Очень часто, и опять же, в случае с использованием Spring Data JPA, нам требуется явно заявить, что такого объекта нет, например, когда речь идёт о сущности в репозитории. В таком случае, мы можем получить объект или, если его нет, выбросить исключение:

User user = repository.findById(userId).orElseThrow(() -> new NoEntityException(userId));

Если сущность не обнаружена и объект null, будет выброшено исключение NoEntityException (в моём случае, кастомное). В моём случае, на клиент уходит строчка «Пользователь {userID} не найден. Проверьте данные запроса».

.orElseGet()

Если объект не найден, Optional оставляет пространство для «Варианта Б» — Вы можете выполнить другой метод, например:

User user = repository.findById(userId).orElseGet(() -> findInAnotherPlace(userId));

Если объект не был найден, предлагается поискать в другом месте.

Этот метод, как и orElseThrow(), использует Supplier. Также, через этот метод можно, опять же, вызвать объект по умолчанию, как и в .orElse():

User user = repository.findById(userId).orElseGet(() -> new User());

Помимо методов получения объектов, существует богатый инструментарий преобразования объекта, морально унаследованный от stream().

Работа с полученным объектом.

Как я писал выше, у Optional имеется неплохой инструментарий преобразования полученного объекта, а именно:

get() — возвращает объект, если он есть.

map() — преобразовывает объект в другой объект.

filter() — фильтрует содержащиеся объекты по предикату.

flatmap() — возвращает множество в виде стрима.

.get()

Метод get() возвращает объект, запакованный в Optional. Например:

User user = repository.findById(userId).get();

Будет получен объект User, запакованный в Optional. Такая конструкция крайне опасна, поскольку минует проверку на null и лишает смысла само использование Optional, поскольку Вы можете получить желаемый объект, а можете получить NPE. Такую конструкцию придётся оборачивать в .isPresent().

.map()

Этот метод полностью повторяет аналогичный метод для stream(), но срабатывает только в том случае, если в Optional есть не-нулловый объект.

String name = repository.findById(userId).map(user -> user.getName()).orElseThrow(() -> new Exception());

В примере мы получили одно из полей класса User, упакованного в Optional.

.filter()

Данный метод также позаимствован из stream() и фильтрует элементы по условию.

List<User> users = repository.findAll().filter(user -> user.age >= 18).orElseThrow(() -> new Exception());

.flatMap()

Этот метод делает ровно то же, что и стримовский, с той лишь разницей, что он работает только в том случае, если значение не null.

[К оглавлению](#start)

---
#### <a name="stream"></a> 6. Streams

---

#### Stream

Stream — это объект для универсальной работы с данными. Мы указываем, какие операции хотим провести, при этом не заботясь о деталях реализации. Например, взять элементы из списка сотрудников, выбрать тех, кто младше 40 лет, отсортировать по фамилии и поместить в новый список. Или чуть сложнее, прочитать все json-файлы, находящиеся в папке books, десериализировать в список объектов книг, обработать элементы всех этих списков, а затем сгруппировать книги по автору.

Данные могут быть получены из источников, коими являются коллекции или методы, поставляющие данные. Например, список файлов, массив строк, метод range() для числовых промежутков и т.д. То есть, стрим использует существующие коллекции для получения новых элементов, это ни в коем случае не новая структура данных.
К данным затем применяются операторы. Например, взять лишь некоторые элементы (filter), преобразовать каждый элемент (map), посчитать сумму элементов или объединить всё в один объект (reduce).
stream.png
Операторы можно разделить на две группы:
     - Промежуточные (intermediate) — обрабатывают поступающие элементы и возвращают стрим. Промежуточных операторов в цепочке обработки элементов может быть много.
     - Терминальные (terminal) — обрабатывают элементы и завершают работу стрима, так что терминальный оператор в цепочке может быть только один.


#### Получение объекта Stream

Пока что хватит теории. Пришло время посмотреть, как создать или получить объект java.util.stream.Stream.
  - Пустой стрим: Stream.empty() // Stream<String>
  - Стрим из List: list.stream() // Stream<String>
  - Стрим из Map: map.entrySet().stream() // Stream<Map.Entry<String, String>>
  - Стрим из массива: Arrays.stream(array) // Stream<String>
  - Стрим из указанных элементов: Stream.of("a", "b", "c") // Stream<String>

А вот и пример:
```
public static void main(String[] args) {
    List<String> list = Arrays.stream(args)
        .filter(s -> s.length() <= 2)
        .collect(Collectors.toList());
}
```

В данном примере источником служит метод Arrays.stream, который из массива args делает стрим. Промежуточный оператор filter отбирает только те строки, длина которых не превышает два. Терминальный оператор collect собирает полученные элементы в новый список.

И ещё один пример:

```
IntStream.of(120, 410, 85, 32, 314, 12)
    .filter(x -> x < 300)
    .map(x -> x + 11)
    .limit(3)
    .forEach(System.out::print)
```

Здесь уже три промежуточных оператора:
  - filter — отбирает элементы, значение которых меньше 300,
  - map — прибавляет 11 к каждому числу,
  - limit — ограничивает количество элементов до 3.

Терминальный оператор forEach применяет функцию print к каждому приходящему элементу.

На ранних версиях Java этот пример выглядел бы так:

```
int[] arr = {120, 410, 85, 32, 314, 12};
int count = 0;
for (int x : arr) {
    if (x >= 300) continue;
    x += 11;
    count++;
    if (count > 3) break;
    System.out.print(x);
}
```

С увеличением числа операторов код в ранних версиях усложнялся бы на порядок, не говоря уже о том, что разбить вычисления на несколько потоков при таком подходе было бы крайне непросто.


#### Как работает стрим?

У стримов есть некоторые особенности. Во-первых, обработка не начнётся до тех пор, пока не будет вызван терминальный оператор. list.stream().filter(x -> x > 100); не возьмёт ни единого элемента из списка. Во-вторых, стрим после обработки нельзя переиспользовать.
```
Stream<String> stream = list.stream();
stream.forEach(System.out::println);
stream.filter(s -> s.contains("Stream API"));
stream.forEach(System.out::println);
```
Код на второй строке выполнится, а вот на третьей выбросит исключение java.lang.IllegalStateException: stream has already been operated upon or closed.

Исходя из первой особенности, делаем вывод, что обработка происходит от терминального оператора к источнику. Это действительно так и это удобно. Мы можем в качестве источника использовать генерируемую бесконечную последовательность, скажем, факториала или чисел Фибоначчи, но обрабатывать лишь некоторую её часть.


Пока мы не присоединили терминальный оператор, доступа к источнику не проводилось. Как только появился терминальный оператор forEach, он стал запрашивать элементы у стоящего перед ним оператора limit. Тот в свою очередь обращается к map, map к filter, а filter уже обращается к источнику. Затем элементы поступают в прямом порядке: источник, filter, map, limit и forEach.
Пока какой-либо из операторов не обработает элемент должным образом, новые запрошены не будут.
Как только через оператор limit прошло 3 элемента, он переходит в закрытое состояние и больше не будет запрашивать элементы у map. forEach запрашивает очередной элемент, но limit сообщает, что больше не может поставить элементов, поэтому forEach делает вывод, что элементы закончились и прекращает работу.

Такой подход зовётся pull iteration, то есть элементы запрашиваются у источника по мере надобности. К слову, в RxJava реализован push iteration подход, то есть источник сам уведомляет, что появились элементы и их нужно обработать.


#### Параллельные стримы

Стримы бывают последовательными (sequential) и параллельными (parallel). Последовательные выполняются только в текущем потоке, а вот параллельные используют общий пул ForkJoinPool.commonPool(). При этом элементы разбиваются (если это возможно) на несколько групп и обрабатываются в каждом потоке отдельно. Затем на нужном этапе группы объединяются в одну для предоставления конечного результата.

Чтобы получить параллельный стрим, нужно либо вызвать метод parallelStream() вместо stream(), либо превратить обычный стрим в параллельный, вызвав промежуточный оператор parallel.
```
list.parallelStream()
    .filter(x -> x > 10)
    .map(x -> x * 2)
    .collect(Collectors.toList());
 
IntStream.range(0, 10)
    .parallel()
    .map(x -> x * 10)
    .sum();
```

Работа с потоконебезопасными коллекциями, разбиение элементов на части, создание потоков, объединение частей воедино, всё это кроется в реализации Stream API. От нас лишь требуется вызвать нужный метод и проследить, чтобы функции в операторах не зависели от каких-либо внешних факторов, иначе есть риск получить неверный результат или ошибку.

Вот так делать нельзя:
```
final List<Integer> ints = new ArrayList<>();
IntStream.range(0, 1000000)
    .parallel()
    .forEach(i -> ints.add(i));
System.out.println(ints.size());
```

Это код Шрёдингера. Он может нормально выполниться и показать 1000000, может выполниться и показать 869877, а может и упасть с ошибкой Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 332 at java.util.ArrayList.add(ArrayList.java:459).

Поэтому разработчики настоятельно просят воздержаться от побочных эффектов в лямбдах, то тут, то там говоря в документации о невмешательстве (non-interference).


#### Стримы для примитивов

Кроме объектных стримов Stream<T>, существуют специальные стримы для примитивных типов:
  - IntStream для int,
  - LongStream для long,
  - DoubleStream для double.

Для boolean, byte, short и char специальных стримов не придумали, но вместо них можно использовать IntStream, а затем приводить к нужному типу. Для float тоже придётся воспользоваться DoubleStream.

Примитивные стримы полезны, так как не нужно тратить время на боксинг/анбоксинг, к тому же у них есть ряд специальных операторов, упрощающих жизнь. Их мы рассмотрим очень скоро.


#### Операторы Stream API

Дальше приводятся операторы Stream API с описанием, демонстрацией и примерами. Можете использовать это как справочник.

#### Источники
```
empty()
```

Стрим, как и коллекция, может быть пустым, а значит всем последующем операторам нечего будет обрабатывать.

```
Stream.empty()
    .forEach(System.out::println);
// Вывода нет
```

```
of(T value)
of(T... values)
```
Стрим для одного или нескольких перечисленных элементов. Очень часто вижу, что используют такую конструкцию:
```
Arrays.asList(1, 2, 3).stream()
    .forEach(System.out::println);
```
однако она излишня. Вот так проще:
```
Stream.of(1, 2, 3)
    .forEach(System.out::println);
```

```
ofNullable(T t)
```
Появился в Java 9. Возвращает пустой стрим, если в качестве аргумента передан null, в противном случае, возвращает стрим из одного элемента.

```
String str = Math.random() > 0.5 ? "I'm feeling lucky" : null;
Stream.ofNullable(str)
    .forEach(System.out::println);
```

```
generate(Supplier s)
```
Возвращает стрим с бесконечной последовательностью элементов, генерируемых функцией Supplier s.
```
Stream.generate(() -> 6)
    .limit(6)
    .forEach(System.out::println);
// 6, 6, 6, 6, 6, 6
```

Поскольку стрим бесконечный, нужно его ограничивать или осторожно использовать, дабы не попасть в бесконечный цикл.

```
iterate​(T seed, UnaryOperator f)
```
Возвращает бесконечный стрим с элементами, которые образуются в результате последовательного применения функции f к итерируемому значению. Первым элементом будет seed, затем f(seed), затем f(f(seed)) и так далее.

```
Stream.iterate(2, x -> x + 6)
    .limit(6)
    .forEach(System.out::println);
// 2, 8, 14, 20, 26, 32
```

```
iterate​(T seed, Predicate hasNext, UnaryOperator f)
```
Появился в Java 9. Всё то же самое, только добавляется ещё один аргумент hasNext: если он возвращает false, то стрим завершается. Это очень похоже на цикл for:
```
for (i = seed; hasNext(i); i = f(i)) {
}
```
Таким образом, с помощью iterate теперь можно создать конечный стрим.
```
Stream.iterate(2, x -> x < 25, x -> x + 6)
    .forEach(System.out::println);
// 2, 8, 14, 20
```

```
concat(Stream a, Stream b)
```
Объединяет два стрима так, что вначале идут элементы стрима A, а по его окончанию последуют элементы стрима B.

```
Stream.concat(
        Stream.of(1, 2, 3),
        Stream.of(4, 5, 6))
    .forEach(System.out::println);
// 1, 2, 3, 4, 5, 6
```

```
builder()
```
Создаёт мутабельный объект для добавления элементов в стрим без использования какого-либо контейнера для этого.
```
Stream.Builder<Integer> streamBuider = Stream.<Integer>builder()
        .add(0)
        .add(1);
for (int i = 2; i <= 8; i += 2) {
    streamBuider.accept(i);
}
streamBuider
    .add(9)
    .add(10)
    .build()
    .forEach(System.out::println);
// 0, 1, 2, 4, 6, 8, 9, 10
```
```
IntStream.range​(int startInclusive, int endExclusive)
LongStream.range​(long startInclusive, long endExclusive)
```
Создаёт стрим из числового промежутка [start..end), то есть от start (включительно) по end.

```
IntStream.range(0, 10)
    .forEach(System.out::println);
// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
```
```
LongStream.range(-10L, -5L)
    .forEach(System.out::println);
// -10, -9, -8, -7, -6
```

```
IntStream.rangeClosed​(int startInclusive, int endInclusive)
LongStream.range​Closed(long startInclusive, long endInclusive)
```
Создаёт стрим из числового промежутка [start..end], то есть от start (включительно) по end (включительно).

```
IntStream.rangeClosed(0, 5)
    .forEach(System.out::println);
// 0, 1, 2, 3, 4, 5
```
``` 
LongStream.range(-8L, -5L)
    .forEach(System.out::println);
// -8, -7, -6, -5
```

#### Промежуточные операторы

```
filter​(Predicate predicate)
```

Фильтрует стрим, принимая только те элементы, которые удовлетворяют заданному условию.

```
Stream.of(1, 2, 3)
    .filter(x -> x == 10)
    .forEach(System.out::print);
// Вывода нет, так как после фильтрации стрим станет пустым
 ```
 ```
Stream.of(120, 410, 85, 32, 314, 12)
    .filter(x -> x > 100)
    .forEach(System.out::println);
// 120, 410, 314
```

```
map​(Function mapper)
```
Применяет функцию к каждому элементу и затем возвращает стрим, в котором элементами будут результаты функции. map можно применять для изменения типа элементов.
```
Stream.mapToDouble​(ToDoubleFunction mapper)
Stream.mapToInt​(ToIntFunction mapper)
Stream.mapToLong​(ToLongFunction mapper)
IntStream.mapToObj(IntFunction mapper)
IntStream.mapToLong(IntToLongFunction mapper)
IntStream.mapToDouble(IntToDoubleFunction mapper)
```
Специальные операторы для преобразования объектного стрима в примитивный, примитивного в объектный, либо примитивного стрима одного типа в примитивный стрим другого.

```
Stream.of("3", "4", "5")
    .map(Integer::parseInt)
    .map(x -> x + 10)
    .forEach(System.out::println);
// 13, 14, 15
```
```
Stream.of(120, 410, 85, 32, 314, 12)
    .map(x -> x + 11)
    .forEach(System.out::println);
// 131, 421, 96, 43, 325, 23
```

```
flatMap​(Function<T, Stream<R>> mapper)
```
Один из самых интересных операторов. Работает как map, но с одним отличием — можно преобразовать один элемент в ноль, один или множество других.
```
flatMapToDouble​(Function mapper)
flatMapToInt​(Function mapper)
flatMapToLong​(Function mapper)
```
Как и в случае с map, служат для преобразования в примитивный стрим.

Для того, чтобы один элемент преобразовать в ноль элементов, нужно вернуть null, либо пустой стрим. Чтобы преобразовать в один элемент, нужно вернуть стрим из одного элемента, например, через Stream.of(x). Для возвращения нескольких элементов, можно любыми способами создать стрим с этими элементами.

```
Stream.of(2, 3, 0, 1, 3)
    .flatMap(x -> IntStream.range(0, x))
    .forEach(System.out::println);
// 0, 1, 0, 1, 2, 0, 0, 1, 2
```

```
Stream.of(1, 2, 3, 4, 5, 6)
    .flatMap(x -> {
         switch (x % 
) {
             case 0:
                 return Stream.of(x, x*x, x*x*
);
             case 1:
                 return Stream.of(x);
             case 2:
             default:
                 return Stream.empty();
         }
     })
    .forEach(System.out::println);
// 1, 3, 9, 18, 4, 6, 36, 72
```
```
limit​(long maxSize)
```
Ограничивает стрим maxSize элементами.
```
Stream.of(120, 410, 85, 32, 314, 12)
    .limit(4)
    .forEach(System.out::println);
// 120, 410, 85, 32
```

```
skip​(long n)
```
Пропускает n элементов стрима.
```
Stream.of(5, 10)
    .skip(40)
    .forEach(System.out::println);
// Вывода нет
```
``` 
Stream.of(120, 410, 85, 32, 314, 12)
    .skip(2)
    .forEach(System.out::println);
// 85, 32, 314, 12
```

```
sorted​()
sorted​(Comparator comparator)
```
Сортирует элементы стрима. Причём работает этот оператор очень хитро: если стрим уже помечен как отсортированный, то сортировка проводиться не будет, иначе соберёт все элементы, отсортирует их и вернёт новый стрим, помеченный как отсортированный. См. 9.1.
```
IntStream.range(0, 100000000)
    .sorted()
    .limit(3)
    .forEach(System.out::println);
// 0, 1, 2
```
``` 
IntStream.concat(
        IntStream.range(0, 100000000),
        IntStream.of(-1, -2))
    .sorted()
    .limit(3)
    .forEach(System.out::println);
// Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
```
```
Stream.of(120, 410, 85, 32, 314, 12)
    .sorted()
    .forEach(System.out::println);
// 12, 32, 85, 120, 314, 410
```
```
Stream.of(120, 410, 85, 32, 314, 12)
    .sorted(Comparator.
natural
Order())
    .forEach(System.out::println);
// 410, 314, 120, 85, 32, 12
```
```
distinct​()
```
Убирает повторяющиеся элементы и возвращаем стрим с уникальными элементами. Как и в случае с sorted, смотрит, состоит ли уже стрим из уникальных элементов и если это не так, отбирает уникальные и помечает стрим как содержащий уникальные элементы.
```
Stream.of(2, 1, 8, 1, 3, 2)
    .distinct​()
    .forEach(System.out::println);
// 2, 1, 8, 3
```

```
peek​(Consumer action)
```
Выполняет действие над каждым элементом стрима и при этом возвращает стрим с элементами исходного стрима. Служит для того, чтобы передать элемент куда-нибудь, не разрывая при этом цепочку операторов (вы же помните, что forEach — терминальный оператор и после него стрим завершается?), либо для отладки.
```
Stream.of(0, 3, 0, 0, 5)
    .peek(x -> System.out.format("before distinct: %d%n", x))
    .distinct()
    .peek(x -> System.out.format("after distinct: %d%n", x))
    .map(x -> x * x)
    .forEach(x -> System.out.format("after map: %d%n", x));
// before distinct: 0
// after distinct: 0
// after map: 0
// before distinct: 3
// after distinct: 3
// after map: 9
// before distinct: 1
// after distinct: 1
// after map: 1
// before distinct: 5
// before distinct: 0
// before distinct: 5
// after distinct: 5
// after map: 25
```
```
takeWhile​(Predicate predicate)
```
Появился в Java 9. Возвращает элементы до тех пор, пока они удовлетворяют условию, то есть функция-предикат возвращает true. Это как limit, только не с числом, а с условием.
```
Stream.of(1, 2, 3, 4, 2, 5)
    .takeWhile(x -> x < 3)
    .forEach(System.out::println);
// 1, 2
```

```
dropWhile​(Predicate predicate)
```
Появился в Java 9. Пропускает элементы до тех пор, пока они удовлетворяют условию, затем возвращает оставшуюся часть стрима. Если предикат вернул для первого элемента false, то ни единого элемента не будет пропущено. Оператор подобен skip, только работает по условию.
```
Stream.of(1, 2, 3, 4, 2, 5)
    .dropWhile(x -> x >= 3)
    .forEach(System.out::println);
// 1, 2, 3, 4, 2, 5
 ```
 ```
Stream.of(1, 2, 3, 4, 2, 5)
    .dropWhile(x -> x < 3)
    .forEach(System.out::println);
// 3, 4, 2, 5
```
```
boxed()
```
Преобразует примитивный стрим в объектный.
```
DoubleStream.of(0.1, Math.PI)
    .boxed()
    .map(Object::getClass)
    .forEach(System.out::println);
// class java.lang.Double
// class java.lang.Double
```

#### Терминальные операторы

```
void forEach​(Consumer action)
```
Выполняет указанное действие для каждого элемента стрима.
```
Stream.of(120, 410, 85, 32, 314, 12)
    .forEach(x -> System.out.format("%s, ", x));
// 120, 410, 85, 32, 314, 12
```
```
void forEachOrdered​(Consumer action)
```
Тоже выполняет указанное действие для каждого элемента стрима, но перед этим добивается правильного порядка вхождения элементов. Используется для параллельных стримов, когда нужно получить правильную последовательность элементов.
```
IntStream.range(0, 100000)
    .parallel()
    .filter(x -> x % 10000 == 0)
    .map(x -> x / 10000)
    .forEach(System.out::println);
// 5, 6, 7, 3, 4, 8, 0, 9, 1, 2
```
```
IntStream.range(0, 100000)
    .parallel()
    .filter(x -> x % 10000 == 0)
    .map(x -> x / 10000)
    .forEachOrdered(System.out::println);
// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
```
```
long count​()
```
Возвращает количество элементов стрима.
```
long count = IntStream.range(0, 10)
    .flatMap(x -> IntStream.range(0, x))
    .count();
System.out.println(count);
// 45
``` 
```
R collect​(Collector collector)
```
Один из самых мощных операторов Stream API. С его помощью можно собрать все элементы в список, множество или другую коллекцию, сгруппировать элементы по какому-нибудь критерию, объединить всё в строку и т.д.. В классе java.util.stream.Collectors очень много методов на все случаи жизни, мы рассмотрим их позже. При желании можно написать свой коллектор, реализовав интерфейс Collector.
```
List<Integer> list = Stream.of(1, 2, 3)
    .collect(Collectors.toList());
// list: [1, 2, 3]
```
```
String s = Stream.of(1, 2, 3)
    .map(String::valueOf)
    .collect(Collectors.joining("-", "<", ">"));
// s: "<1-2-3>"
```
```
R collect​(Supplier supplier, BiConsumer accumulator, BiConsumer combiner)
```
То же, что и collect(collector), только параметры разбиты для удобства. Если нужно быстро сделать какую-то операцию, нет нужды реализовывать интерфейс Collector, достаточно передать три лямбда-выражения.

supplier должен поставлять новые объекты (контейнеры), например new ArrayList(), accumulator добавляет элемент в контейнер, combiner необходим для параллельных стримов и объединяет части стрима воедино.
```
List<String> list = Stream.of("a", "b", "c", "d")
    .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
// list: ["a", "b", "c", "d"]
```
```
Object[] toArray​()
```
Возвращает нетипизированный массив с элементами стрима.
```
A[] toArray​(IntFunction<A[]> generator)
```
Аналогично, только возвращает типизированный массив.

```
String[] elements = Stream.of("a", "b", "c", "d")
    .toArray(String[]::new);
// elements: ["a", "b", "c", "d"]
```
```
T reduce​(T identity, BinaryOperator accumulator)
U reduce​(U identity, BiFunction accumulator, BinaryOperator combiner)
```
Ещё один полезный оператор. Позволяет преобразовать все элементы стрима в один объект. Например, посчитать сумму всех элементов, либо найти минимальный элемент.

Сперва берётся объект identity и первый элемент стрима, применяется функция accumulator и identity становится её результатом. Затем всё продолжается для остальных элементов.
```
int sum = Stream.of(1, 2, 3, 4, 5)
    .reduce(10, (acc, x) -> acc + x);
// sum: 25
```
```
Optional reduce​(BinaryOperator accumulator)
```
Этот метод отличается тем, что у него нет начального объекта identity. В качестве него служит первый элемент стрима. Поскольку стрим может быть пустой и тогда identity объект не присвоится, то результатом функции служит Optional, позволяющий обработать и эту ситуацию, вернув Optional.empty().
```
Optional<Integer> result = Stream.<Integer>empty()
    .reduce((acc, x) -> acc + x);
System.out.println(result.isPresent());
// false
```
``` 
Optional<Integer> sum = Stream.of(1, 2, 3, 4, 5)
    .reduce((acc, x) -> acc + x);
System.out.println(sum.get());
// 15
```
```
Optional min​(Comparator comparator)
Optional max​(Comparator comparator)
```
Поиск минимального/максимального элемента, основываясь на переданном компараторе. Внутри вызывается reduce:
```
reduce((a, b) -> comparator.compare(a, b) <= 0 ? a : b));
reduce((a, b) -> comparator.compare(a, b) >= 0 ? a : b));
```
```
int min = Stream.of(20, 11, 45, 78, 13)
    .min(Integer::compare).get();
// min: 11
 
int max = Stream.of(20, 11, 45, 78, 13)
    .max(Integer::compare).get();
// max: 78
```
```
Optional findAny​()
```
Возвращает первый попавшийся элемент стрима. В параллельных стримах это может быть действительно любой элемент, который лежал в разбитой части последовательности.
```
Optional findFirst​()
```
Гарантированно возвращает первый элемент стрима, даже если стрим параллельный.

Если нужен любой элемент, то для параллельных стримов быстрее будет работать findAny().
```
int anySeq = IntStream.range(4, 65536)
    .findAny()
    .getAsInt();
// anySeq: 4
 
int firstSeq = IntStream.range(4, 65536)
    .findFirst()
    .getAsInt();
// firstSeq: 4
 
int anyParallel = IntStream.range(4, 65536)
    .parallel()
    .findAny()
    .getAsInt();
// anyParallel: 32770
 
int firstParallel = IntStream.range(4, 65536)
    .parallel()
    .findFirst()
    .getAsInt();
// firstParallel: 4
```
```
boolean allMatch​(Predicate predicate)
```
Возвращает true, если все элементы стрима удовлетворяют условию predicate. Если встречается какой-либо элемент, для которого результат вызова функции-предиката будет false, то оператор перестаёт просматривать элементы и возвращает false.
```
boolean result = Stream.of(1, 2, 3, 4, 5)
    .allMatch(x -> x <= 7);
// result: true

boolean result = Stream.of(1, 2, 3, 4, 5)
    .allMatch(x -> x < 3);
// result: false
```
```
boolean anyMatch​(Predicate predicate)
```
Возвращает true, если хотя бы один элемент стрима удовлетворяет условию predicate. Если такой элемент встретился, нет смысла продолжать перебор элементов, поэтому сразу возвращается результат.
```
boolean result = Stream.of(1, 2, 3, 4, 5)
    .anyMatch(x -> x == 3);
// result: true

boolean result = Stream.of(1, 2, 3, 4, 5)
    .anyMatch(x -> x == 8);
// result: false
```
```
boolean noneMatch​(Predicate predicate)
```
Возвращает true, если, пройдя все элементы стрима, ни один не удовлетворил условию predicate. Если встречается какой-либо элемент, для которого результат вызова функции-предиката будет true, то оператор перестаёт перебирать элементы и возвращает false.
```
boolean result = Stream.of(1, 2, 3, 4, 5)
    .noneMatch(x -> x == 9);
// result: true

boolean result = Stream.of(1, 2, 3, 4, 5)
    .noneMatch(x -> x == 3);
// result: false
```
```
OptionalDouble average​()
```
Только для примитивных стримов. Возвращает среднее арифметическое всех элементов. Либо Optional.empty, если стрим пуст.
```
double result = IntStream.range(2, 16)
    .average()
    .getAsDouble();
// result: 8.5
```
```
sum()
```
Возвращает сумму элементов примитивного стрима. Для IntStream результат будет типа int, для LongStream — long, для DoubleStream — double.
```
long result = LongStream.range(2, 16)
    .sum();
// result: 119
```
```
IntSummaryStatistics summaryStatistics()
```
Полезный метод примитивных стримов. Позволяет собрать статистику о числовой последовательности стрима, а именно: количество элементов, их сумму, среднее арифметическое, минимальный и максимальный элемент.
```
LongSummaryStatistics stats = LongStream.range(2, 16)
    .summaryStatistics();
System.out.format("  count: %d%n", stats.getCount());
System.out.format("    sum: %d%n", stats.getSum());
System.out.format("average: %.1f%n", stats.getAverage());
System.out.format("    min: %d%n", stats.getMin());
System.out.format("    max: %d%n", stats.getMax());
//   count: 14
//     sum: 119
// average: 8,5
//     min: 2
//     max: 15
```
#### Методы Collectors
```
toList​()
```
Самый распространённый метод. Собирает элементы в List.
```
toSet​()
```
Собирает элементы в множество.

```
toCollection​(Supplier collectionFactory)
```
Собирает элементы в заданную коллекцию. Если нужно конкретно указать, какой List, Set или другую коллекцию мы хотим использовать, то этот метод поможет.
```
Deque<Integer> deque = Stream.of(1, 2, 3, 4, 5)
    .collect(Collectors.toCollection(ArrayDeque::new));
 
Set<Integer> set = Stream.of(1, 2, 3, 4, 5)
    .collect(Collectors.toCollection(LinkedHashSet::new));
```
```
toMap​(Function keyMapper, Function valueMapper)
```
Собирает элементы в Map. Каждый элемент преобразовывается в ключ и в значение, основываясь на результате функций keyMapper и valueMapper соответственно. Если нужно вернуть тот же элемент, что и пришел, то можно передать Function.identity().
```
Map<Integer, Integer> map1 = Stream.of(1, 2, 3, 4, 5)
    .collect(Collectors.toMap(
        Function.identity(),
        Function.identity()
    ));
// {1=1, 2=2, 3=3, 4=4, 5=5}
 
Map<Integer, String> map2 = Stream.of(1, 2, 3)
    .collect(Collectors.toMap(
        Function.identity(),
        i -> String.format("%d * 2 = %d", i, i * 2)
    ));
// {1="1 * 2 = 2", 2="2 * 2 = 4", 3="3 * 2 = 6"}
 
Map<Character, String> map3 = Stream.of(50, 54, 55)
    .collect(Collectors.toMap(
        i -> (char) i.intValue(),
        i -> String.format("<%d>", i)
    ));
// {'2'="<50>", '6'="<54>", '7'="<55>"}
```
```
toMap​(Function keyMapper, Function valueMapper, BinaryOperator mergeFunction)
```
Аналогичен первой версии метода, только в случае, когда встречается два одинаковых ключа, позволяет объединить значения.
```
Map<Integer, String> map4 = Stream.of(50, 55, 69, 20, 19, 52)
    .collect(Collectors.toMap(
        i -> i % 5,
        i -> String.format("<%d>", i),
        (a, b) -> String.join(", ", a, b)
    ));
// {0="<50>, <55>, <20>", 2="<52>", 4="<64>, <19>"}
```
В данном случае, для чисел 50, 55 и 20, ключ одинаков и равен 0, поэтому значения накапливаются. Для 64 и 19 аналогично.
```
toMap​(Function keyMapper, Function valueMapper, BinaryOperator mergeFunction, Supplier mapFactory)
```
Всё то же, только позволяет указывать, какой именно класс Map использовать.
```
Map<Integer, String> map5 = Stream.of(50, 55, 69, 20, 19, 52)
    .collect(Collectors.toMap(
        i -> i % 5,
        i -> String.format("<%d>", i),
        (a, b) -> String.join(", ", a, b),
        LinkedHashMap::new
    ));
// {0=<50>, <55>, <20>, 4=<69>, <19>, 2=<52>}
```
Отличие этого примера от предыдущего в том, что теперь сохраняется порядок, благодаря LinkedHashList.
```
toConcurrentMap​(Function keyMapper, Function valueMapper)
toConcurrentMap​(Function keyMapper, Function valueMapper, BinaryOperator mergeFunction)
toConcurrentMap​(Function keyMapper, Function valueMapper, BinaryOperator mergeFunction, Supplier mapFactory)
```
Всё то же самое, что и toMap, только работаем с ConcurrentMap.

```
collectingAndThen​(Collector downstream, Function finisher)
```
Собирает элементы с помощью указанного коллектора, а потом применяет к полученному результату функцию.
```
List<Integer> list = Stream.of(1, 2, 3, 4, 5)
    .collect(Collectors.collectingAndThen(
        Collectors.toList(),
        Collections::unmodifiableList));
System.out.println(list.getClass());
// class java.util.Collections$UnmodifiableRandomAccessList
 
List<String> list2 = Stream.of("a", "b", "c", "d")
    .collect(Collectors.collectingAndThen(
            Collectors.toMap(Function.identity(), s -> s + s),
            map -> map.entrySet().stream()))
    .map(e -> e.toString())
    .collect(Collectors.collectingAndThen(
            Collectors.toList(),
            Collections::unmodifiableList));
list2.forEach(System.out::println);
// a=aa
// b=bb
// c=cc
// d=dd
```
```
joining​()
joining​(CharSequence delimiter)
joining​(CharSequence delimiter, CharSequence prefix, CharSequence suffix)
```
Собирает элементы, реализующие интерфейс CharSequence, в единую строку. Дополнительно можно указать разделитель, а также префикс и суффикс для всей последовательности.
```
String s1 = Stream.of("a", "b", "c", "d")
    .collect(Collectors.joining());
System.out.println(s1);
// abcd
 
String s2 = Stream.of("a", "b", "c", "d")
    .collect(Collectors.joining("-"));
System.out.println(s2);
// a-b-c-d
 
String s3 = Stream.of("a", "b", "c", "d")
    .collect(Collectors.joining(" -> ", "[ ", " ]"));
System.out.println(s3);
// [ a -> b -> c -> d ]
```
```
summingInt​(ToIntFunction mapper)
summingLong​(ToLongFunction mapper)
summingDouble​(ToDoubleFunction mapper)
```
Коллектор, который преобразовывает объекты в int/long/double и подсчитывает сумму.
```
averagingInt​(ToIntFunction mapper)
averagingLong​(ToLongFunction mapper)
averagingDouble​(ToDoubleFunction mapper)
```
Аналогично, но со средним значением.
```
summarizingInt​(ToIntFunction mapper)
summarizingLong​(ToLongFunction mapper)
summarizingDouble​(ToDoubleFunction mapper)
```
Аналогично, но с полной статистикой.
```
Integer sum = Stream.of("1", "2", "3", "4")
    .collect(Collectors.summingInt(Integer::parseInt));
System.out.println(sum);
// 10
 
Double average = Stream.of("1", "2", "3", "4")
    .collect(Collectors.averagingInt(Integer::parseInt));
System.out.println(average);
// 2.5
 
DoubleSummaryStatistics stats = Stream.of("1.1", "2.34", "3.14", "4.04")
    .collect(Collectors.summarizingDouble(Double::parseDouble));
System.out.println(stats);
// DoubleSummaryStatistics{count=4, sum=10.620000, min=1.100000, average=2.655000, max=4.040000}
```
Все эти методы и несколько последующих, зачастую используются в качестве составных коллекторов для группировки или collectingAndThen. В том виде, в котором они показаны на примерах используются редко. Я лишь показываю пример, что они возвращают, чтобы было понятнее.

```
counting​()
```
Подсчитывает количество элементов.
```
Long count = Stream.of("1", "2", "3", "4")
    .collect(Collectors.counting());
System.out.println(count);
// 4
```
```
filtering​(Predicate predicate, Collector downstream)
mapping​(Function mapper, Collector downstream)
flatMapping​(Function downstream)
reducing​(BinaryOperator op)
reducing​(T identity, BinaryOperator op)
reducing​(U identity, Function mapper, BinaryOperator op)
```
Специальная группа коллекторов, которая применяет операции filter, map, flatMap и reduce. filtering​ и flatMapping​ появились в Java 9.
```
List<Integer> ints = Stream.of(1, 2, 3, 4, 5, 6)
    .collect(Collectors.filtering(
        x -> x % 2 == 0,
        Collectors.toList()));
// 2, 4, 6
 
String s1 = Stream.of(1, 2, 3, 4, 5, 6)
    .collect(Collectors.filtering(
        x -> x % 2 == 0,
        Collectors.mapping(
            x -> Integer.toString(x),
            Collectors.joining("-")
        )
    ));
// 2-4-6
 
String s2 = Stream.of(2, 0, 1, 3, 2)
    .collect(Collectors.flatMapping(
        x -> IntStream.range(0, x).mapToObj(Integer::toString),
        Collectors.joining(", ")
    ));
// 0, 1, 0, 0, 1, 2, 0, 1
 
int value = Stream.of(1, 2, 3, 4, 5, 6)
    .collect(Collectors.reducing(
        0, (a, b) -> a + b
    ));
// 21
String s3 = Stream.of(1, 2, 3, 4, 5, 6)
    .collect(Collectors.reducing(
        "", x -> Integer.toString(x), (a, b) -> a + b
    ));
// 123456
```
```
minBy​(Comparator comparator)
maxBy​(Comparator comparator)
```
Поиск минимального/максимального элемента, основываясь на заданном компараторе.
```
Optional<String> min = Stream.of("ab", "c", "defgh", "ijk", "l")
    .collect(Collectors.minBy(Comparator.comparing(String::length)));
min.ifPresent(System.out::println);
// c
 
Optional<String> max = Stream.of("ab", "c", "defgh", "ijk", "l")
    .collect(Collectors.maxBy(Comparator.comparing(String::length)));
max.ifPresent(System.out::println);
// defgh
```
```
groupingBy​(Function classifier)
groupingBy​(Function classifier, Collector downstream)
groupingBy​(Function classifier, Supplier mapFactory, Collector downstream)
```
Группирует элементы по критерию, сохраняя результат в Map. Вместе с представленными выше агрегирующими коллекторами, позволяет гибко собирать данные. Подробнее о комбинировании в разделе Примеры.
```
groupingByConcurrent​(Function classifier)
groupingByConcurrent​(Function classifier, Collector downstream)
groupingByConcurrent​(Function classifier, Supplier mapFactory, Collector downstream)
```
Аналогичный набор методов, только сохраняет в ConcurrentMap.
```
Map<Integer, List<String>> map1 = Stream.of(
    "ab", "c", "def", "gh", "ijk", "l", "mnop")
    .collect(Collectors.groupingBy(String::length));
map1.entrySet().forEach(System.out::println);
// 1=[c, l]
// 2=[ab, gh]
// 3=[def, ijk]
// 4=[mnop]
 
Map<Integer, String> map2 = Stream.of(
    "ab", "c", "def", "gh", "ijk", "l", "mnop")
    .collect(Collectors.groupingBy(
        String::length,
        Collectors.mapping(
            String::toUpperCase,
            Collectors.joining())
    ));
map2.entrySet().forEach(System.out::println);
// 1=CL
// 2=ABGH
// 3=DEFIJK
// 4=MNOP
 
Map<Integer, List<String>> map3 = Stream.of(
    "ab", "c", "def", "gh", "ijk", "l", "mnop")
    .collect(Collectors.groupingBy(
        String::length,
        LinkedHashMap::new,
        Collectors.mapping(
            String::toUpperCase,
            Collectors.toList())
    ));
map3.entrySet().forEach(System.out::println);
// 2=[AB, GH]
// 1=[C, L]
// 3=[DEF, IJK]
// 4=[MNOP]
```
```
partitioningBy​(Predicate predicate)
partitioningBy​(Predicate predicate, Collector downstream)
```
Ещё один интересный метод. Разбивает последовательность элементов по какому-либо критерию. В одну часть попадают все элементы, которые удовлетворяют переданному условию, во вторую — все, которые не удовлетворяют.
```
Map<Boolean, List<String>> map1 = Stream.of(
    "ab", "c", "def", "gh", "ijk", "l", "mnop")
    .collect(Collectors.partitioningBy(s -> s.length() <= 2));
map1.entrySet().forEach(System.out::println);
// false=[def, ijk, mnop]
// true=[ab, c, gh, l]
 
Map<Boolean, String> map2 = Stream.of(
    "ab", "c", "def", "gh", "ijk", "l", "mnop")
    .collect(Collectors.partitioningBy(
        s -> s.length() <= 2,
        Collectors.mapping(
            String::toUpperCase,
            Collectors.joining())
    ));
map2.entrySet().forEach(System.out::println);
// false=DEFIJKMNOP
// true=ABCGHL
```

#### Collector

Интерфейс java.util.stream.Collector служит для сбора элементов стрима в некоторый мутабельный контейнер. Он состоит из таких методов:
   - Supplier<A> supplier() — функция, которая создаёт экземпляры контейнеров.
   - BiConsumer<A,T> accumulator() — функция, которая кладёт новый элемент в контейнер.
   - BinaryOperator<A> combiner() — функция, которая объединяет два контейнера в один. В параллельных стримах каждая часть может собираться в отдельный экземпляр контейнера и в итоге необходимо их объединять в один результирующий.
   - Function<A,R> finisher() — функция, которая преобразовывает весь контейнер в конечный результат. Например, можно обернуть List в Collections.unmodifiableList.
   - Set<Characteristics> characteristics() — возвращает характеристики коллектора, чтобы внутренняя реализация знала, с чем имеет дело. Например, можно указать, что коллектор поддерживает многопоточность.

Характеристики:
   - CONCURRENT — коллектор поддерживает многопоточность, а значит отдельные части стрима могут быть успешно положены в контейнер из другого потока.
   - UNORDERED — коллектор не зависит от порядка поступаемых элементов.
   - IDENTITY_FINISH — функция finish() имеет стандартную реализацию (Function.identity()), а значит её можно не вызывать.

#### Реализация собственного коллектора

Прежде чем писать свой коллектор, нужно убедиться, что задачу нельзя решить при помощи комбинации стандартных коллекторов.
К примеру, если нужно собрать лишь уникальные элементы в список, то можно собрать элементы сначала в LinkedHashSet, чтобы сохранился порядок, а потом все элементы добавить в ArrayList. Комбинация collectingAndThen с toCollection и функцией, передающей полученный Set в конструктор ArrayList, делает то, что задумано:
```
Stream.of(1, 2, 3, 1, 9, 2, 5, 3, 4, 8, 2)
    .collect(Collectors.collectingAndThen(
        Collectors.toCollection(LinkedHashSet::new),
        ArrayList::new));
// 1 2 3 9 5 4 8
```
А вот если задача состоит в том, чтобы собрать уникальные элементы в одну часть, а повторяющиеся в другую, например в Map<Boolean, List>, то при помощи partitioningBy получится не очень красиво:
```
final Set<Integer> elements = new HashSet<>();
Stream.of(1, 2, 3, 1, 9, 2, 5, 3, 4, 8, 2)
    .collect(Collectors.partitioningBy(elements::add))
    .forEach((isUnique, list) -> System.out.format("%s: %s%n", isUnique ? "unique" : "repetitive", list));
Здесь приходится создавать Set и в предикате коллектора его использовать, что нежелательно. Можно превратить лямбду в анонимную функцию, но это ещё хуже:

new Predicate<Integer>() {
    final Set<Integer> elements = new HashSet<>();
    @Override
    public boolean test(Integer t) {
        return elements.add(t);
    }
}
```
Для создания своего коллектора есть два пути:
   1. Создать класс, реализующий интерфейс Collector.
   2. Воспользоваться фабрикой Collector.of.
Если нужно сделать что-то универсальное, чтобы работало для любых типов, то есть использовать дженерики, то во втором варианте можно просто сделать статическую функцию, а внутри использовать Collector.of.

Вот полученный коллектор.
```
public static <T> Collector<T, ?, Map<Boolean, List<T>>> partitioningByUniqueness() {
    return Collector.<T, Map.Entry<List<T>, Set<T>>, Map<Boolean, List<T>>>of(
        () -> new AbstractMap.SimpleImmutableEntry<>(
                    new ArrayList<T>(), new LinkedHashSet<>()),
        (c, e) -> {
            if (!c.getValue().add(e)) {
                c.getKey().add(e);
            }
        },
        (c1, c2) -> {
            c1.getKey().addAll(c2.getKey());
            for (T e : c2.getValue()) {
                if (!c1.getValue().add(e)) {
                    c1.getKey().add(e);
                }
            }
            return c1;
        },
        c -> {
            Map<Boolean, List<T>> result = new HashMap<>(2);
            result.put(Boolean.FALSE, c.getKey());
            result.put(Boolean.TRUE, new ArrayList<>(c.getValue()));
            return result;
        });
}
```
Давайте теперь разбираться.

Интерфейс Collector объявлен так:
interface Collector<T, A, R>
  * T - тип входных элементов.
  * A - тип контейнера, в который будут поступать элементы.
  * R - тип результата.

Сигнатура метода, возвращающего коллектор такова:
```
public static <T> Collector<T, ?, Map<Boolean, List<T>>> partitioningByUniqueness()
```
Он принимает элементы типа T, возвращает Map<Boolean, List<T>>, как и partitioningBy. Знак вопроса (джокер) в среднем параметре говорит о том, что внутренний тип реализации для публичного API не важен. Многие методы класса Collectors содержат джокер в качестве типа контейнера.
```
return Collector.<T, Map.Entry<List<T>, Set<T>>, Map<Boolean, List<T>>>of
```
Вот здесь уже пришлось указать тип контейнера. Так как в Java нет класса Pair или Tuple, то два разных типа можно положить в Map.Entry.

```
// supplier
() -> new AbstractMap.SimpleImmutableEntry<>(
        new ArrayList<>(), new LinkedHashSet<>())
```
Контейнером будет AbstractMap.SimpleImmutableEntry. В ключе будет список повторяющихся элементов, в значении — множество с уникальными элементами.
```
// accumulator
(c, e) -> {
    if (!c.getValue().add(e)) {
        c.getKey().add(e);
    }
}
```
Здесь всё просто. Если элемент нельзя добавить во множество (по причине того, что там уже есть такой элемент), то добавляем его в список повторяющихся элементов.

```
// combiner
(c1, c2) -> {
    c1.getKey().addAll(c2.getKey());
    for (T e : c2.getValue()) {
        if (!c1.getValue().add(e)) {
            c1.getKey().add(e);
        }
    }
    return c1;
}
```
Нужно объединить два Map.Entry. Списки повторяющихся элементов можно объединить вместе, а вот с уникальными элементами так просто не выйдет — нужно пройтись поэлементно и повторить всё то, что делалось в функции-аккумуляторе. Кстати, лямбду-аккумулятор можно присвоить переменной и тогда цикл можно превратить в c2.getValue().forEach(e -> accumulator.accept(c1, e));

```
// finisher
c -> {
    Map<Boolean, List<T>> result = new HashMap<>(2);
    result.put(Boolean.FALSE, c.getKey());
    result.put(Boolean.TRUE, new ArrayList<>(c.getValue()));
    return result;
}
```
Наконец, возвращаем необходимый результат. В map.get(Boolean.TRUE) будут уникальные, а в map.get(Boolean.FALSE) — повторяющиеся элементы.
```
Map<Boolean, List<Integer>> map;
map = Stream.of(1, 2, 3, 1, 9, 2, 5, 3, 4, 8, 2)
    .collect(partitioningByUniqueness());
// {false=[1, 2, 3, 2], true=[1, 2, 3, 9, 5, 4, 8]}
```
Хорошей практикой является создание коллекторов, которые принимают ещё один коллектор и зависят от него. Например, можно будет складывать элементы не только в List, но и в любую другую коллекцию (Collectors.toCollection), либо в строку (Collectors.joining).
```
public static <T, D, A> Collector<T, ?, Map<Boolean, D>> partitioningByUniqueness(
        Collector<? super T, A, D> downstream) {
    class Holder<A, B> {
        final A unique, repetitive;
        final B set;
        Holder(A unique, A repetitive, B set) {
            this.unique = unique;
            this.repetitive = repetitive;
            this.set = set;
        }
    }
    BiConsumer<A, ? super T> downstreamAccumulator = downstream.accumulator();
    BinaryOperator<A> downstreamCombiner = downstream.combiner();
    BiConsumer<Holder<A, Set<T>>, T> accumulator = (t, element) -> {
        A container = t.set.add(element) ? t.unique : t.repetitive;
        downstreamAccumulator.accept(container, element);
    };
    return Collector.<T, Holder<A, Set<T>>, Map<Boolean, D>>of(
            () -> new Holder<>(
                downstream.supplier().get(),
                downstream.supplier().get(),
                new HashSet<>() ),
            accumulator,
            (t1, t2) -> {
                downstreamCombiner.apply(t1.repetitive, t2.repetitive);
                t2.set.forEach(e -> accumulator.accept(t1, e));
                return t1;
            },
            t -> {
                Map<Boolean, D> result = new HashMap<>(2);
                result.put(Boolean.FALSE, downstream.finisher().apply(t.repetitive));
                result.put(Boolean.TRUE, downstream.finisher().apply(t.unique));
                t.set.clear();
                return result;
            });
}
```
Алгоритм остался тем же, только теперь уже нельзя во второй контейнер сразу же складывать уникальные элементы, приходится создавать новый set. Для удобства также добавлен класс Holder, который хранит два контейнера для уникальных и повторяющихся элементов, а также само множество.

Все операции теперь нужно проводить через переданный коллектор, именуемый downstream. Именно он сможет поставить контейнер нужного типа (downstream.supplier().get()), добавить элемент в этот контейнер (downstream.accumulator().accept(container, element)), объединить контейнеры и создать окончательный результат.
```
Stream.of(1, 2, 3, 1, 9, 2, 5, 3, 4, 8, 2)
    .map(String::valueOf)
    .collect(partitioningByUniqueness(Collectors.joining("-")))
    .forEach((isUnique, str) -> System.out.format("%s: %s%n", isUnique ? "unique" : "repetitive", str));
// repetitive: 1-2-3-2
// unique: 1-2-3-9-5-4-8
```
Кстати, первую реализацию метода без аргументов можно теперь заменить на:
```
public static <T> Collector<T, ?, Map<Boolean, List<T>>> partitioningByUniqueness() {
    return partitioningByUniqueness(Collectors.toList());
}
```

[К оглавлению](#start)